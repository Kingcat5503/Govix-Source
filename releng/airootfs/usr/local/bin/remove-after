#!/usr/bin/env bash
set -euo pipefail

# remove-after: remove packages from an installed system after installer finishes
#
# This script is intended to run in the live environment (or from an installer
# script) after installation completes and before first boot. It will remove
# a list of packages from the installed root (chroot) using pacman.
#
# Usage:
#   remove-after [--root ROOT] [--file PACKAGELIST] [--dry-run]
#
# Defaults:
#   ROOT=/mnt (or supplied)
#   PACKAGELIST=/usr/local/etc/remove-after-packages.txt

ROOT="/mnt"
PACKAGELIST="/usr/local/etc/remove-after-packages.txt"
DRY_RUN=false

usage() {
	cat <<EOF
Usage: $(basename "$0") [options]

Options:
	--root PATH       Path to the installed root (default: ${ROOT})
	--file PATH       File containing packages to remove (one pkg per line)
										(default: ${PACKAGELIST})
	--dry-run         Print actions instead of executing them
	-h, --help        Show this help and exit

This script removes packages (and optionally calamares) from the installed
root using pacman -Rns. It's safe to run multiple times; missing packages are
ignored.
EOF
}

while [[ ${#} -gt 0 ]]; do
	case "$1" in
		--root)
			ROOT="$(readlink -f "$2")"
			shift 2
			;;
		--file)
			PACKAGELIST="$2"
			shift 2
			;;
		--dry-run)
			DRY_RUN=true
			shift
			;;
		-h|--help)
			usage
			exit 0
			;;
		*)
			echo "Unknown option: $1" >&2
			usage
			exit 2
			;;
	esac
done

if [[ ! -d "${ROOT}" ]]; then
	echo "Installed root not found at: ${ROOT}" >&2
	exit 1
fi

# Resolve package list file path inside chroot (absolute or relative to script)
if [[ -f "${PACKAGELIST}" ]]; then
	LIST_PATH="${PACKAGELIST}"
elif [[ -f "${ROOT}${PACKAGELIST}" ]]; then
	LIST_PATH="${ROOT}${PACKAGELIST}"
else
	LIST_PATH=""
fi

pkgs_to_remove=()

if [[ -n "${LIST_PATH}" && -f "${LIST_PATH}" ]]; then
	while IFS= read -r line; do
		pkg="$(echo "$line" | sed -e 's/[[:space:]]*#.*$//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
		[[ -z "$pkg" ]] && continue
		pkgs_to_remove+=("$pkg")
	done < "${LIST_PATH}"
fi

# Always ensure calamares and its modules are removed if present
# Add common calamares package names; pacman will ignore missing packages.
pkgs_to_remove+=(calamares calamares-git calamares-qt calamares-python)

# Deduplicate while preserving order
declare -A seen
unique_pkgs=()
for p in "${pkgs_to_remove[@]:-}"; do
	if [[ -z "${p}" ]]; then
		continue
	fi
	if [[ -z "${seen[$p]:-}" ]]; then
		seen[$p]=1
		unique_pkgs+=("$p")
	fi
done

if [[ ${#unique_pkgs[@]} -eq 0 ]]; then
	echo "No packages to remove." 
	exit 0
fi

echo "Packages to remove from ${ROOT}: ${unique_pkgs[*]}"

pacman_cmd=(pacman -Rns --noconfirm)

if [[ "${DRY_RUN}" = true ]]; then
	echo "Dry run enabled. Commands that would run:"
	echo "chroot ${ROOT} ${pacman_cmd[*]} ${unique_pkgs[*]}"
	exit 0
fi

# Perform removal inside chroot. Use --cachedir and DB paths if necessary.
if [[ $(id -u) -ne 0 ]]; then
	echo "This script must be run as root to chroot and remove packages." >&2
	exit 1
fi

if ! mountpoint -q "${ROOT}"; then
	echo "Warning: ${ROOT} is not a mountpoint. Continuing if directories exist."
fi

echo "Running pacman removal inside chroot..."
chroot "${ROOT}" /bin/bash -c "${pacman_cmd[*]} ${unique_pkgs[*]} || true"

echo "Removing leftover calamares files if any..."
rm -rf "${ROOT}/etc/calamares" || true
rm -rf "${ROOT}/usr/share/calamares" || true

echo "Optionally run: chroot ${ROOT} pacman -Scc --noconfirm to clear caches inside installed root"

echo "Done."
